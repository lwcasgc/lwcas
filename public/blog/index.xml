<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>blog on lwcas</title>
    <link>https://example.com/blog/</link>
    <description>Recent content in blog on lwcas</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <managingEditor>lwcasgc@gmail.com (lwcas)</managingEditor>
    <webMaster>lwcasgc@gmail.com (lwcas)</webMaster>
    <copyright>lwcas</copyright>
    <lastBuildDate>Mon, 10 Nov 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://example.com/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>#2: packets in online games</title>
      <link>https://example.com/blog/packes_in_games/</link>
      <pubDate>Mon, 10 Nov 2025 00:00:00 +0000</pubDate><author>lwcasgc@gmail.com (lwcas)</author>
      <guid>https://example.com/blog/packes_in_games/</guid>
      <description>&lt;h1 id=&#34;what-are-packets-in-multiplayer-games&#34;&gt;what are packets in multiplayer games?&lt;/h1&gt;&#xA;&lt;p&gt;in multiplayer games, packets are like the envelopes or messages that carry information between players&amp;rsquo; devices and the game server. they ensure that actions like moving your character, shooting, or chatting are synchronized across all players in real-time. without packets, online gaming would be impossible—everyone would be playing in their own isolated world.&lt;/p&gt;&#xA;&lt;p&gt;imagine you&amp;rsquo;re playing a team-based game with friends:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;server:&lt;/strong&gt; the central hub that knows everything happening in the game world.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;clients:&lt;/strong&gt; each player&amp;rsquo;s device, sending updates to the server and receiving updates from others.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;packets:&lt;/strong&gt; the data bundles that travel over the internet, containing things like &amp;ldquo;player x moved to position (10, 20)&amp;rdquo; or &amp;ldquo;player Yy fired a bullet.&amp;rdquo;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;packets make sure everyone sees the same game state, even with network delays or losses. but if packets get lost or arrive out of order, it can cause glitches like rubber-banding or desyncs.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="what-are-packets-in-multiplayer-games">what are packets in multiplayer games?</h1>
<p>in multiplayer games, packets are like the envelopes or messages that carry information between players&rsquo; devices and the game server. they ensure that actions like moving your character, shooting, or chatting are synchronized across all players in real-time. without packets, online gaming would be impossible—everyone would be playing in their own isolated world.</p>
<p>imagine you&rsquo;re playing a team-based game with friends:</p>
<ul>
<li><strong>server:</strong> the central hub that knows everything happening in the game world.</li>
<li><strong>clients:</strong> each player&rsquo;s device, sending updates to the server and receiving updates from others.</li>
<li><strong>packets:</strong> the data bundles that travel over the internet, containing things like &ldquo;player x moved to position (10, 20)&rdquo; or &ldquo;player Yy fired a bullet.&rdquo;</li>
</ul>
<p>packets make sure everyone sees the same game state, even with network delays or losses. but if packets get lost or arrive out of order, it can cause glitches like rubber-banding or desyncs.</p>
<h2 id="how-packets-work-in-practice">how packets work in practice</h2>
<p>packets are sent using network protocols, mainly TCP and UDP:</p>
<ul>
<li><strong>tcp (transmission control protocol):</strong> reliable but slower. it guarantees packets arrive in order and retransmits lost ones. used for important data like login info or inventory changes.</li>
<li><strong>udp (user datagram protocol):</strong> fast but unreliable. packets might get lost, but no waiting for retransmission. used for real-time actions like movement updates.</li>
</ul>
<p>in games, a mix is often used. for example, movement might use udp for speed, while chat messages use tcp for reliability.</p>
<p>simple packet example (conceptual, not actual code):</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// imagine sending a position update
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">position_packet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Packet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">    </span><span class="n">player_id</span>: <span class="mi">1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">    </span><span class="n">x</span>: <span class="mf">100.0</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">    </span><span class="n">y</span>: <span class="mf">200.0</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">    </span><span class="n">timestamp</span>: <span class="nc">get_current_time</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="w"></span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="w"></span><span class="n">send_to_server</span><span class="p">(</span><span class="n">position_packet</span><span class="p">);</span></span></span></code></pre></div><p>on the server, it processes and broadcasts to other players:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// server receives and relays
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">receive_from_client</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">    </span><span class="n">broadcast_to_all_clients</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></div><h2 id="why-packet-handling-matters">why packet handling matters</h2>
<p>poor packet management can ruin the experience:</p>
<ul>
<li><strong>latency (ping):</strong> time for a packet to go to the server and back. high latency causes delays in actions.</li>
<li><strong>packet loss:</strong> some packets don&rsquo;t arrive. games interpolate missing data to smooth it out.</li>
<li><strong>jitter:</strong> inconsistent delays. causes stuttering.</li>
<li><strong>security:</strong> packets can be spoofed or tampered with, so games use encryption and validation.</li>
</ul>
<p>these issues are why games have &ldquo;netcode&rdquo; – the system handling network communication. good netcode predicts movements and corrects errors to keep the game fair and fun.</p>
<h2 id="extras">extras</h2>
<p><strong>dead reckoning:</strong> predicting player positions based on last known data to hide latency. like assuming a car keeps moving straight until new info arrives.</p>
<p><strong>rollback netcode:</strong> rewinding time to correct mistakes from lost packets, used in fighting games for precise timing.</p>
]]></content:encoded>
    </item>
    <item>
      <title>#1: rust borrow</title>
      <link>https://example.com/blog/rust_borrow/</link>
      <pubDate>Fri, 11 Jul 2025 00:00:00 +0000</pubDate><author>lwcasgc@gmail.com (lwcas)</author>
      <guid>https://example.com/blog/rust_borrow/</guid>
      <description>&lt;h1 id=&#34;what-is-borrow-in-rust&#34;&gt;what is &amp;ldquo;borrow&amp;rdquo; in rust?&lt;/h1&gt;&#xA;&lt;p&gt;borrow in rust is a way to use a value without taking ownership of it. instead of moving a value from one place to another, you can &amp;ldquo;borrow&amp;rdquo; it using references. this helps rust ensure memory safety without needing a garbage collector.&lt;/p&gt;&#xA;&lt;p&gt;imagine you and a friend share a laptop with a draft document:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;owner:&lt;/strong&gt; you own the laptop and the sole editable copy of the draft.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;immutable borrow (viewing):&lt;/strong&gt; you give your friend a read-only copy or open the file in &amp;ldquo;view only&amp;rdquo; mode — multiple friends can view the draft at the same time, nobody can change it.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;mutable borrow (editing):&lt;/strong&gt; you hand the laptop to one friend or grant exclusive edit access — that friend can modify the draft, but while they have edit access you (and others) cannot edit it.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;lifetimes:&lt;/strong&gt; the borrow lasts while the friend has the laptop or edit session; when they finish and return it, you regain full access.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;the result: many memory errors are caught before the program runs, so code is safer without needing a garbage collector.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="what-is-borrow-in-rust">what is &ldquo;borrow&rdquo; in rust?</h1>
<p>borrow in rust is a way to use a value without taking ownership of it. instead of moving a value from one place to another, you can &ldquo;borrow&rdquo; it using references. this helps rust ensure memory safety without needing a garbage collector.</p>
<p>imagine you and a friend share a laptop with a draft document:</p>
<ul>
<li><strong>owner:</strong> you own the laptop and the sole editable copy of the draft.</li>
<li><strong>immutable borrow (viewing):</strong> you give your friend a read-only copy or open the file in &ldquo;view only&rdquo; mode — multiple friends can view the draft at the same time, nobody can change it.</li>
<li><strong>mutable borrow (editing):</strong> you hand the laptop to one friend or grant exclusive edit access — that friend can modify the draft, but while they have edit access you (and others) cannot edit it.</li>
<li><strong>lifetimes:</strong> the borrow lasts while the friend has the laptop or edit session; when they finish and return it, you regain full access.</li>
</ul>
<p>the result: many memory errors are caught before the program runs, so code is safer without needing a garbage collector.</p>
<h2 id="how-it-works-in-practice">how it works in practice</h2>
<ul>
<li>immutable borrow (reading): you borrow only to read. in rust this is <code>&amp;</code>.</li>
<li>mutable borrow (changing): you borrow to modify. in rust this is <code>&amp;mut</code>.</li>
</ul>
<p>immutable borrow:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="ln">1</span><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">laptop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;draft document&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// you own the laptop with the draft
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">viewer1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">laptop</span><span class="p">;</span><span class="w"> </span><span class="c1">// friend1 opens in &#34;view only&#34; mode
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">viewer2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">laptop</span><span class="p">;</span><span class="w"> </span><span class="c1">// friend2 also views at the same time
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">viewer1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">viewer2</span><span class="p">);</span></span></span></code></pre></div><p>mutable borrow:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="ln">1</span><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">laptop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;intro&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="s">&#34;body&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()];</span><span class="w"> </span><span class="c1">// owner of the document parts
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">editor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">laptop</span><span class="p">;</span><span class="w"> </span><span class="c1">// one friend gets exclusive edit access
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">editor</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&#34;conclusion&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span><span class="w"> </span><span class="c1">// friend edits the document
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">editor</span><span class="p">);</span></span></span></code></pre></div><p>more abstract &amp;mut example showing immediate update and scope:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="ln">1</span><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">laptop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;raft v1&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// owner
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">editor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">laptop</span><span class="p">;</span><span class="w"> </span><span class="c1">// exclusive edit session starts
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">editor</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&#34; — updated&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// changes happen immediately on the laptop
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">editor</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;draft v1 — updated&#34;
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w"> </span><span class="c1">// editor goes out of scope here
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="c1"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">laptop</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;draft v1 — updated&#34; — owner can access again
</span></span></span></code></pre></div><p>example that will not compile:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="ln">1</span><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">laptop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;draft v1&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">editor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">laptop</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w"></span><span class="c1">// println!(&#34;{}&#34;, laptop); // error: cannot borrow `laptop` as immutable while `editor` (a mutable borrow) exists
</span></span></span></code></pre></div><h2 id="why-these-rules-exist">why these rules exist</h2>
<p>these rules prevent common mistakes like using something that was already removed or modifying something at the same time (which can cause unexpected behavior). they help rust guarantee <strong>memory safety</strong> at compile time.</p>
<p><strong>memory safety</strong> means a program can&rsquo;t read or write memory it shouldn&rsquo;t. this prevents common bugs like:</p>
<ul>
<li>
<p><strong>use-after-free</strong>: reading data after it was dropped</p>
<ul>
<li>can cause undefined behavior: crashes, corrupted memory, or wrong values</li>
<li>security risk: may allow attackers to execute code or disclose sensitive data</li>
<li>typically timing-dependent and hard to reproduce, making bugs elusive</li>
</ul>
</li>
<li>
<p><strong>double-free</strong>: freeing the same memory twice</p>
<ul>
<li>leads to heap/allocator corruption and undefined behavior, often crashing the program</li>
<li>can corrupt allocator metadata so future allocations return invalid pointers</li>
<li>a common vector for exploitation (control-flow hijack or arbitrary code execution)</li>
</ul>
</li>
<li>
<p><strong>data races</strong>: two threads changing the same data at once</p>
<ul>
<li>causes nondeterministic behavior, lost updates, and inconsistent reads (corrupted state)
<ul>
<li>can produce crashes, deadlocks, or subtle logic errors that are hard to reproduce</li>
<li>may break program invariants and create security issues when sensitive data is involved</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="extras">extras</h2>
<p>garbage collector: a garbage collector (gc) is a runtime component that automatically detects and reclaims memory a program no longer uses, so developers don&rsquo;t have to manually free memory. this simplifies development but adds runtime overhead, potential pause times, and less predictable performance. rust instead provides deterministic, compile-time memory safety via ownership, borrowing, and lifetimes, dropping values at well-defined points without a gc.</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
